// Generated by CoffeeScript 1.8.0
(function() {
  var check, child_process, fs, isFolderNewer, path, spawnOrDie, util;

  child_process = require("child_process");

  fs = require("fs");

  path = require("path");

  util = require("util");

  check = function(sourcePath, targetPath, options, callback) {
    if (options == null) {
      options = {};
    }
    if ((callback == null) && (typeof options === "function")) {
      callback = options;
      options = {};
    }
    options.command || (options.command = ["./node_modules/.bin/coffee", "-o", targetPath, "-c", sourcePath]);
    options.transform || (options.transform = function(filename) {
      return filename.replace(/.coffee$/, ".js");
    });
    if (!isFolderNewer(sourcePath, targetPath, options.transform)) {
      return callback();
    }
    if (!options.quiet) {
      console.log("Source is newer; recompiling...");
    }
    return spawnOrDie(options.command, {
      detached: true,
      stdio: "inherit"
    }, function() {
      var trueCommand;
      trueCommand = Array.prototype.concat([process.execPath], process.execArgv, process.argv.slice(1));
      return spawnOrDie(trueCommand, {
        detached: true,
        stdio: "inherit"
      }, function() {});
    });
  };

  spawnOrDie = function(command, options, callback) {
    var failed, p;
    failed = function(message) {
      console.log("Unable to run: " + command.join(" "));
      console.log("Failed to recompile -- " + message);
      return process.exit(1);
    };
    p = child_process.spawn(command[0], command.slice(1), options);
    p.on("error", function(error) {
      return failed(error.stack);
    });
    return p.on("exit", function(code, signal) {
      if (code == null) {
        failed("signal " + signal);
      }
      if (code !== 0) {
        failed("error code " + code);
      }
      return callback();
    });
  };

  isFolderNewer = function(sourcePath, targetPath, transform) {
    var filename, newer, sourceFilename, sourceStat, targetFilename, targetStat, _i, _len, _ref;
    _ref = fs.readdirSync(sourcePath);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      filename = _ref[_i];
      sourceFilename = path.join(sourcePath, filename);
      targetFilename = path.join(targetPath, transform(filename));
      if (!fs.existsSync(targetFilename)) {
        return true;
      }
      sourceStat = fs.statSync(sourceFilename);
      targetStat = fs.statSync(targetFilename);
      if (sourceStat.isDirectory() !== targetStat.isDirectory()) {
        return true;
      }
      newer = sourceStat.isDirectory() ? isFolderNewer(sourceFilename, targetFilename, transform) : targetStat.mtime < sourceStat.mtime;
      if (newer) {
        return true;
      }
    }
    return false;
  };

  exports.check = check;

}).call(this);
